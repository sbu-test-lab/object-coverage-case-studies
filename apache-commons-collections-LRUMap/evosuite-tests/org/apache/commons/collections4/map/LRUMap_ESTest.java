/*
 * This file was automatically generated by EvoSuite
 * Mon Jan 11 15:26:20 GMT 2021
 */

package org.apache.commons.collections4.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.SequenceInputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.collections4.map.AbstractHashedMap;
import org.apache.commons.collections4.map.AbstractLinkedMap;
import org.apache.commons.collections4.map.LRUMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.junit.runner.RunWith;

 
public class LRUMap_ESTest{

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      HashMap<SequenceInputStream, String> hashMap0 = new HashMap<SequenceInputStream, String>();
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      hashMap0.put(sequenceInputStream0, "NPE, entry=");
      LRUMap<SequenceInputStream, String> lRUMap0 = new LRUMap<SequenceInputStream, String>(hashMap0);
      lRUMap0.size = 1103;
      int int0 = lRUMap0.maxSize();
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(1, int0);
      assertTrue(lRUMap0.isFull());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      LRUMap<Integer, LRUMap<String, Object>> lRUMap0 = new LRUMap<Integer, LRUMap<String, Object>>(100);
      lRUMap0.modCount = 2756;
      boolean boolean0 = lRUMap0.isFull();
      assertFalse(boolean0);
      assertEquals(100, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Integer integer0 = new Integer(4990);
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>(4990);
      lRUMap0.clear();
      AbstractHashedMap.HashEntry<String, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<String, String>((AbstractHashedMap.HashEntry<String, String>) null, 0, integer0, "setValue() can only be called after next() and before remove()");
      AbstractLinkedMap.LinkEntry<String, String> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<String, String>(abstractHashedMap_HashEntry0, 0, integer0, (String) null);
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping(abstractLinkedMap_LinkEntry0, 0, (-2981), "K", ".");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=K value=. size=0 maxSize=4990 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Integer integer0 = new Integer(4990);
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>(4990);
      AbstractHashedMap.HashEntry<String, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<String, String>((AbstractHashedMap.HashEntry<String, String>) null, 0, integer0, "setValue() can only be called after next() and before remove()");
      AbstractLinkedMap.LinkEntry<String, String> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<String, String>(abstractHashedMap_HashEntry0, 0, integer0, (String) null);
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping(abstractLinkedMap_LinkEntry0, (-13), (-2981), "K", ".");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=K value=. size=0 maxSize=4990 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Integer integer0 = new Integer(4990);
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>(4990);
      AbstractHashedMap.HashEntry<String, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<String, String>((AbstractHashedMap.HashEntry<String, String>) null, 0, integer0, "setValue() can only be called after next() and before remove()");
      lRUMap0.putIfAbsent(" previous=", " previous=");
      AbstractLinkedMap.LinkEntry<String, String> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<String, String>(abstractHashedMap_HashEntry0, 0, integer0, (String) null);
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping(abstractLinkedMap_LinkEntry0, 0, (-2981), "K", ".");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=K value=. size=1 maxSize=4990 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      HashMap<SequenceInputStream, String> hashMap0 = new HashMap<SequenceInputStream, String>();
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      SequenceInputStream sequenceInputStream1 = new SequenceInputStream(sequenceInputStream0, sequenceInputStream0);
      hashMap0.put(sequenceInputStream1, "NPE, entry=");
      hashMap0.put(sequenceInputStream0, "}\"@MIn");
      LRUMap<SequenceInputStream, String> lRUMap0 = new LRUMap<SequenceInputStream, String>(hashMap0);
      lRUMap0.size = 1103;
      lRUMap0.putIfAbsent(sequenceInputStream0, (String) null);
      assertTrue(lRUMap0.isFull());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      LRUMap<Integer, String> lRUMap0 = new LRUMap<Integer, String>(10, false);
      Integer integer0 = new Integer(10);
      lRUMap0.addMapping(10, 0, integer0, "v`3WRl(");
      assertEquals(10, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      LRUMap<String, Object> lRUMap0 = new LRUMap<String, Object>(2788, 16);
      MockPrintStream mockPrintStream0 = new MockPrintStream("L:&X8v's");
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(mockPrintStream0);
      lRUMap0.doWriteObject(objectOutputStream0);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(2788, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      LRUMap<String, Object> lRUMap0 = new LRUMap<String, Object>(9, true);
      boolean boolean0 = lRUMap0.isScanUntilRemovable();
      assertTrue(boolean0);
      assertEquals(9, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      HashMap<SequenceInputStream, String> hashMap0 = new HashMap<SequenceInputStream, String>();
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      hashMap0.put(sequenceInputStream0, "}\"@MIn");
      LRUMap<SequenceInputStream, String> lRUMap0 = new LRUMap<SequenceInputStream, String>(hashMap0);
      LRUMap<SequenceInputStream, String> lRUMap1 = lRUMap0.clone();
      assertTrue(lRUMap1.isFull());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      LRUMap<Integer, String> lRUMap0 = new LRUMap<Integer, String>(1085, 1435.7664F);
      AbstractHashedMap.HashEntry<Integer, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<Integer, String>((AbstractHashedMap.HashEntry<Integer, String>) null, 2591, lRUMap0, "");
      AbstractLinkedMap.LinkEntry<Integer, String> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<Integer, String>(abstractHashedMap_HashEntry0, 1085, (Object) null, "=");
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry(abstractLinkedMap_LinkEntry0, "=");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      LRUMap<LRUMap<Object, String>, String> lRUMap0 = new LRUMap<LRUMap<Object, String>, String>(640);
      // Undeclared exception!
      try { 
        lRUMap0.moveToMRU((AbstractLinkedMap.LinkEntry<LRUMap<Object, String>, String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>();
      // Undeclared exception!
      try { 
        lRUMap0.addMapping(2616, (-1537), ":OPX/#u", "Entry.after=null, header.after=");
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2616
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      LRUMap<Integer, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Integer, String>((Map<? extends Integer, ? extends String>) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      AbstractHashedMap<String, Integer> abstractHashedMap0 = new AbstractHashedMap<String, Integer>(0);
      LRUMap<String, Integer> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<String, Integer>(abstractHashedMap0, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      LRUMap<Integer, Integer> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Integer, Integer>((Map<? extends Integer, ? extends Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      LRUMap<Integer, Integer> lRUMap0 = new LRUMap<Integer, Integer>(47, 16, 16, true);
      LRUMap<Object, Integer> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<Object, Integer>(lRUMap0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      LRUMap<String, LRUMap<Object, Object>> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<String, LRUMap<Object, Object>>(0, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      LRUMap<InputStream, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<InputStream, String>(125, 125, 0.0F);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, Object>(0, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      LRUMap<String, LRUMap<Object, Object>> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<String, LRUMap<Object, Object>>(0, 0.75F, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      LRUMap<Object, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, String>((-1), 0.0F);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      LRUMap<LRUMap<String, String>, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<LRUMap<String, String>, Object>(0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      LRUMap<String, SequenceInputStream> lRUMap0 = new LRUMap<String, SequenceInputStream>(16, 16, 16);
      Integer integer0 = new Integer((-3013));
      lRUMap0.get((Object) integer0, false);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(16, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      HashMap<Integer, SequenceInputStream> hashMap0 = new HashMap<Integer, SequenceInputStream>(12, 12);
      Integer integer0 = new Integer(125);
      Enumeration<SequenceInputStream> enumeration0 = (Enumeration<SequenceInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      hashMap0.put(integer0, sequenceInputStream0);
      LRUMap<Integer, SequenceInputStream> lRUMap0 = new LRUMap<Integer, SequenceInputStream>(hashMap0, true);
      assertTrue(lRUMap0.isFull());
      assertTrue(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>(1824, 1824, false);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(1824, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>(4990, 0);
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping((AbstractLinkedMap.LinkEntry<String, String>) null, 0, (-2981), "K", "");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // NPE, entry=null entryIsHeader=false key=K value= size=0 maxSize=4990 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      LRUMap<Object, String> lRUMap0 = new LRUMap<Object, String>(2, true);
      AbstractLinkedMap.LinkEntry<Object, String> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      // Undeclared exception!
      try { 
        lRUMap0.moveToMRU(abstractLinkedMap_LinkEntry0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Can't move header to MRU This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      LRUMap<Object, SequenceInputStream> lRUMap0 = new LRUMap<Object, SequenceInputStream>(4990, 4990);
      Integer integer0 = new Integer(3148);
      lRUMap0.get((Object) integer0);
      assertEquals(4990, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      LRUMap<InputStream, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<InputStream, String>(12, 274, 12, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap initial size must not be greater than max size
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      LRUMap<SequenceInputStream, SequenceInputStream> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<SequenceInputStream, SequenceInputStream>((-1), 5293, 1907L, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      LRUMap<LRUMap<Object, Object>, String> lRUMap0 = new LRUMap<LRUMap<Object, Object>, String>(4174, false);
      AbstractHashedMap.HashEntry<LRUMap<Object, Object>, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<LRUMap<Object, Object>, String>((AbstractHashedMap.HashEntry<LRUMap<Object, Object>, String>) null, 595, (Object) null, "org.apache.commons.collections4.map.AbstractHashedMap$Values");
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry(abstractHashedMap_HashEntry0, "org.apache.commons.collections4.map.AbstractHashedMap$Values");
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // org.apache.commons.collections4.map.AbstractHashedMap$HashEntry cannot be cast to org.apache.commons.collections4.map.AbstractLinkedMap$LinkEntry
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      LRUMap<Object, SequenceInputStream> lRUMap0 = new LRUMap<Object, SequenceInputStream>();
      // Undeclared exception!
      try { 
        lRUMap0.doWriteObject((ObjectOutputStream) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      HashMap<SequenceInputStream, String> hashMap0 = new HashMap<SequenceInputStream, String>();
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      hashMap0.put(sequenceInputStream0, "");
      LRUMap<SequenceInputStream, String> lRUMap0 = new LRUMap<SequenceInputStream, String>(hashMap0);
      lRUMap0.putAll(hashMap0);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertTrue(lRUMap0.isFull());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      LRUMap<Integer, AbstractLinkedMap.LinkEntry<Object, SequenceInputStream>> lRUMap0 = new LRUMap<Integer, AbstractLinkedMap.LinkEntry<Object, SequenceInputStream>>(2);
      // Undeclared exception!
      try { 
        lRUMap0.doReadObject((ObjectInputStream) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      LRUMap<InputStream, Object> lRUMap0 = new LRUMap<InputStream, Object>();
      boolean boolean0 = lRUMap0.isScanUntilRemovable();
      assertEquals(100, lRUMap0.maxSize());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      LRUMap<String, SequenceInputStream> lRUMap0 = new LRUMap<String, SequenceInputStream>(646);
      boolean boolean0 = lRUMap0.removeLRU((AbstractLinkedMap.LinkEntry<String, SequenceInputStream>) null);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertTrue(boolean0);
      assertEquals(646, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      LRUMap<Object, LRUMap<Object, Object>> lRUMap0 = new LRUMap<Object, LRUMap<Object, Object>>(4223, 4223);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>();
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry((AbstractHashedMap.HashEntry<Object, LRUMap<Object, Object>>) null, lRUMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      LRUMap<Object, String> lRUMap0 = new LRUMap<Object, String>(3169, 0, 1.0F, true);
      LRUMap<Object, String> lRUMap1 = lRUMap0.clone();
      assertTrue(lRUMap1.isScanUntilRemovable());
      assertEquals(3169, lRUMap1.maxSize());
  }
}
